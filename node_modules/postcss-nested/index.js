CÜ1ƒ¦ñÇüœä—VXÑrkóı#\1fñÆ_œæŸ‡‡ŠÜbK³}ıØë±Cß=şózl‚NşûxP
kë®«–4V¢(UÖT\ÙÏAŸ<Ì=ã?0‰/&ùåL_å°±aêü‹6ØÑvs'Ìûñ­M×]W-_ª¡ƒûò	|0©¯æ÷à$¿\UkE… ¢$ª¾¾Í¦®Ïûò	|°?ş”OxıõáaÑëÏ(<z’y:8¡—c†ºk¼—U[R#hÀQ¥Íİj[Ó½]Ÿ=Ê5ÓüsÎOOüóÂ™e‰$EJ«êoè÷à±/_WoM•ÂY#†¨¶®îâNNåšiı5·çæş|Ü(øR2Õ–õxä—Lé§bÙ*­êå˜®Îêşü‘®î¾I|1“Wf÷ŞD?í»ı×ë±]Ÿ=ì½c_>¿·5ÛÒ¢pÖ|©’ÆJ“k&¯LçŸ
f!fòötrÊ ·ŒwáÄ>›İ{³_»(‰b%­¶®îâ¡ïÿ9=5½ÿæúl¿çö}ø ·|õ¼Ÿü÷ëë¯ª´ {µuu÷uX·çîl¹«ÑŠ
¹Ó&ŠRsiı}Öá‰3}uCƒÅuó¥J+uşlÛnîà„ÎOûò	|°»õÎ†E2$•(JÛÍœĞóÑİŸ?½ÿæıøä¿_UkE…E²n»¹ƒfùæŒ_ŞÿÊ/<täğ°ØÙ#†ëõØ®òÎÙ¼3¥ŸæıøêÚ++æJ$BÌäérV]Ûã‘İ;í¿çşüÂŠ‹êDIÔÓQı8Æ%Ãİ7æ¥ı×ç¡c^:üısxbâŸÇ‡’X[w]µ|©„¸Ù¾OğÆNíøä	|0‹7&üñ¬ß'¥²¶îºjí6vqF?pÃ(×Ìıù$1„N•/cÑÙ½7Å³«¾¾Ñ®!îç¢I~9ÓW÷µÛÓ$oÊ±Ç½¸êÒúú8¤»óú<tYµ’Åpà`)r4Û×vs§§ö|ôd¿òÏ;[®¯¾´fözìHWzëÈWOúë©ÿ¾ªVíåMötxb¯Ç{ïØ—Ïë±É}7ùïw·^Z³P–¼)C'ÈV°ÏC;>yÄ+‡½w6ïLé§	<ë·÷‡…ÅßòŸ	„…õ· ÒªÖÛ»8côë§ğÃÜ›à‡Ë«Ï\ }–B™‹·ÛØx÷0÷ŒuÙøLå—ù<_JfuíeµÂÂb&ïë°OğÆ	|0‹7æúì„?e±´jØ‰£ÆJš*ß^ˆ",,C‘¬…Ç¸$_ºP‘³/¨¶®öòNNéïÀ¡ït„+@ğ5Rå«·°úúVÛ:;­ßƒÇ»/.”C¢hÁ‰©X­eyÒÒßY‹ötÔL_]Y³Õ¶!î˜Å³}wÒ_Ïıù¥Uƒ!jâJ«:;­ÏC»>{J?í8hôÄáa}äìì°áî‹¥±¾şÊŠKj„Š¼¶ná¬yR$!HÊ¼Y
µÚÖtoÏGrËw|ód¾™×c“ûnâŸ'ˆ2àsxb*¿Ìè¥Ù¾;ç§§ş{’‘C¥Ê—¾@×gpÃÈWÿŒ_å?J¤`Æé»8£¯Ã:<q¤«†»oª¿Îşı¸P‹*-È9TĞ€k-k²§›s¾yôëgùæÚºËj%‹‘ tË­Öç¡ øT~™ÏCs|rºÿÎùé%U
g",¬—cº:k¨»F½6>”Ä¾vÅ3Ê’2o–Bµ—7ÜÙË1ƒÜ2â•ß<şÓÿ?N”Å¦F!#EO’}AÕµõ7ô|ô4ş˜Ë3“ür¦¯Ë¶«UŸ‡wßœšî¿ƒ]6è­şxâŸçMpĞôšïà†	|0‹7æøäD?İ;iĞùÿ²æ¢:‰£F
+iwçsÑ`·MöÛY¿=õßãNù¬ªµ¢BQÕXRm]G'õxd·çwá ·Îä•™½6Í?'ıõòêyR$‰#Yºœ-¶4Û×ıù£]7è­#_=½ÿæødñìÅ2åN(t‚¬…+®¬½¼ƒ†¹gÄ+‡½w:ÿLî»iş9û÷UZ=a´Ôùk.­¾¾Ÿƒ:;m.ÏLè£Y¿Êauí•—Ô!J¢ŒEë-¬¼ºı4Àc]6à3{mŠ?ÎóÑ8PÉbUZUsiõõ}ÒÙiCÜ1ÚuCŞ9‹7æúì´ÿûó3FK˜­`Ç'pÅ$¾˜âó|töïË–,F¤áê,ª¸r”k†ºk¼'ñÅlŞ™ã“ÓıwÎOÇòÈ—.Q”AÒå¬±¤îâ.Îà†Q®ûò9?JaW«×-˜-ê`C'ˆ‘¬Æ’šK«¯o³©ıÖå™==Ä£_?G¦öÛ?œô×ó/8Q-wrÍX—xå<™ÏC“új’_Nı÷­M·µZQ¡X¦ÄQÓåÌP¤åÖîÎëùèş/ê®ñ.ùêù<4µßfşú†ËjE3y–BÕ×7Û×Åã]8‹7&öÙôÿßØpS›b™rÄ‘¬Æ’jëÚĞÕYã?0§§fûî¤¿ŞŞ<_ªh	«­k½½‹3º=w[Fºj’_ÎôÕıÙíóÌğ°€k¯¬2RÔÄõ74Ş=À#_=şs{n‚Núë¸Q*ÔYÔÅ]Õá‰=İıùCŞ9fñÆ\ŸóÓñ£D–T)œ5bˆ°°¬…+¯n@?}÷˜È'“ûn¦¯N÷ßµu×UK+Q”Tù²¬°¢Ñ®.Îèç aïâs}6rèĞ	b$k±¥Ù¾Şâ±/Ÿè§³}7n”ÇâÊÒ§Í­`óı½3É/lì¶iÿ$Æœšê¯3~9^”Æ6ëÊ=I–B-·ösĞ0÷LòË™¾º±á¦6Ò‡Œ5q¥U=ÑÍ9==Ô]ÓùgNOÍşı¸PÅ²åI;GÊ¼ÍöõpÄ ·ŒvİwÎå™	}4İ76ÜPmÕ¼)#‡
pš\İœÓå™ı_0ÖeŞ8§§&öÙ„?.–-t‚Tùz:ªïÃGºjOLä“	JagËé“Å)C‘z;9¥ÏC¼qôë×Öš¸áÎ.Ïì÷à1.™Ê/³}wuí|©šïïúìñ˜Äs}vÂï¯¿<èw„‡Å¨R8k”Dis×ZVumg§õ{ğHWwß„>šÛs³}wÊ?¯­»¢Bò˜	£¥/PeMË­Í÷rÍ¸~û”~šİ{“ıvÆ/ÇY]{E…4¹šìi¾¿C¸a”k&õÕÄ?%9t°À™‹×\Úıùc\2‹7&ôQ<)•-
fË“"BÑ¯ŸØg³|3PXˆˆYWYÓõÙı_0şSùeNüóÙ¿_4k‘•VU^İrkóııÜùé3ziZMûïxP
‹+/¬—<fÂhMö´ÛØ×aİ;Æ%ß<‘Oæ÷à¶f[ZÉ3]ìœĞå™Ÿ<öåóyh[³\i‚D¨°bŒKÆ¼tä«g÷ŞŒ_ŞÕjyíœé’ÇL‘'[ÁªkëoèãîÎëıø!îöŞ¼0füòìßåP4k¾T‘BÆL^cI7çôuØ6kªÎ:AŸ‡|ótş™ë³!#ÆH–&W»İŸ?½ÿæøäæÆ[Z,È^,Sˆˆ±sÔXRm]7çôxä—tÓà·Ïã‘•5£&£Ñ®®ÎêïÀAoâó|tûíAçúkxXô::êµÓùg¦¯.¯¾´fî´‰£F
YaEÍ¥Õ×÷sP·çö}ø ·Îà…É~›3eØQÅJÚ`Gëí]œ1Ä£]7ôİSûmNöÛ8S6+æJ9TĞ€³®¸²õöîÎëóĞ1/şş	~8Ûw§üóêÚkª$Œ(<VÒTùšìi½½ûóÇºlÀ'ôÑÜ›	ìi³¾zò˜‚¤ÊWaEíåMötyfïÇ{ï~˜ĞG³zkÖoÇ2XW¯P–d1„N_ ÊšöôuXÇ'÷~üè×Oä“	~8Ùoçıøä¿_S§xæÄQ3«µ¬İÆ~êşüÁnùêáïŸŞ3}u]½5U‚ eŞJ«íêë°æ±.›Ë3Óú+”BÜ("Y’ÇÌP$ká¶›{9¦ÏC;>yà›çğÄ,ßœñËs>”AñìÅ2%µpÅ•M÷öxd÷çzëøLñÇ9?½¥Iôƒe-Üş€ÎOáŠÑ¯ŸÂ³|sÊ?Ïûñ…gÍ“"t‚XIìh¼»£“º<³ç£Ç¹h°Û&õÕÌ^›ùë{ÛæO0ZÄ™ŠÕZÖz{g§tÓh×Mâ‹éı7Ë7§üó¼Ï:VÒèæœ®æ™¼2­¿&şùæÆêçˆ,pæâ5—6ÜÙñÉ½?«·¦ûïÌ_ßßßqAçùgxX¥¨ƒŞ:»÷¦ûïœŸ^^}iÍ[léûğQ¯Õ[“şziÕ<)b$ëä”æ±.›ĞG“ûnŠ?NûïxP
q£<r¥Š£ÁnÎéôÔ¡îøæÙ½7ñÏ÷´)’!à YWYÓl_GtwŞwŒ~ıä¾›è§³}7”Â6KjÍ8X¬¤ÙTZÕpg‡txâxNå—¾8Í?§ş{¼(…Õ‰$TäE²n½½£“º>»ÿÆ`*¿Lî»¾JaO›%5ŠfL%à 1“W^İbK/ÇtxbÿrËÀ7Ïá‰‰|2İçüôâÊKjäˆ8jÊ¼ÙT_ßfS?uyæWsÏĞwÏâ)ı4ã—÷´)’!S±ìj.m·±ñîÎOç¢É|3³×¦÷ß´ÿ¥P0cØ‰£FI”.g…]5‰/fôÒtÿóÓ.¯½²bèÙÔ[Øş€NNíºAoşş‰|2Ÿ‡æõØôş›ü÷ñ v¶\=Wšd1RçÏX´Í¦èæœîÏè¦!ïœÁq¡Šg2à Ñ¦Ì›­`Eu·ÚÖÁ	Ÿ<æ¥SûmÖoïiS$CĞ€³j»¹¯Ã:<q¸ûF¾z.ÏÌúí©ÿ¾ B°ÀM_ Úºêë›ïïè¤¼0æôÔœŸŞÖÿñAû;/<,TÅEu"…ÔncãİŸ>ì½c_>Åçùh<(…¸Q*Ì–±h%=Ñë±İŸ?úõq âMéÊ”3]ª|é´Û8Æ%ß<¿'ùåôÿ_V-i¬³/h¶¯Ç#'òÉ\ŸòÏq¥\64È—*i¬NóÒ©ı¶´j¡,ySÆJZeMG'vİ,Ş˜ÑKSşyO›
+ì˜Àsyf¢ŸÎöİM6Ô/’!gº˜Éë,j¼»CF¸b°ÛfòÊtş™ì·3~yYµ<)bçH¿åÖNèå˜éªáîşşy=6½ÿ¦ùgœ(‹mÍ’ÇL-VÒKª­ëæœ®Ïîÿ‚pe: 'unknown' }
}

function getAncestorRules(leaf) {
  let lineage = []
  let parent = leaf.parent

  while (parent && parent instanceof AtRule) {
    lineage.push(parent)
    parent = parent.parent
  }
  return lineage
}

function unwrapRootRule(rule) {
  let escapes = rule[rootRuleEscapes]

  if (!escapes) {
    rule.after(rule.nodes)
  } else {
    let nodes = rule.nodes

    let topEscaped
    let topEscapedIdx = -1
    let breakoutLeaf
    let breakoutRoot
    let clone

    let lineage = getAncestorRules(rule)
    lineage.forEach((parent, i) => {
      if (escapes(parent.name)) {
        topEscaped = parent
        topEscapedIdx = i
        breakoutRoot = clone
      } else {
        let oldClone = clone
        clone = parent.clone({ nodes: [] })
        oldClone && clone.append(oldClone)
        breakoutLeaf = breakoutLeaf || clone
      }
    })

    if (!topEscaped) {
      rule.after(nodes)
    } else if (!breakoutRoot) {
      topEscaped.after(nodes)
    } else {
      let leaf = breakoutLeaf
      leaf.append(nodes)
      topEscaped.after(breakoutRoot)
    }

    if (rule.next() && topEscaped) {
      let restRoot
      lineage.slice(0, topEscapedIdx + 1).forEach((parent, i, arr) => {
        let oldRoot = restRoot
        restRoot = parent.clone({ nodes: [] })
        oldRoot && restRoot.append(oldRoot)

        let nextSibs = []
        let _child = arr[i - 1] || rule
        let next = _child.next()
        while (next) {
          nextSibs.push(next)
          next = next.next()
        }
        restRoot.append(nextSibs)
      })
      restRoot && (breakoutRoot || nodes[nodes.length - 1]).after(restRoot)
    }
  }

  rule.remove()
}

const rootRuleMergeSel = Symbol('rootRuleMergeSel')
const rootRuleEscapes = Symbol('rootRuleEscapes')

function normalizeRootRule(rule) {
  let { params } = rule
  let { type, selector, escapes } = parseRootRuleParams(params)
  if (type === 'unknown') {
    throw rule.error(
      `Unknown @${rule.name} parameter ${JSON.stringify(params)}`
    )
  }
  if (type === 'basic' && selector) {
    let selectorBlock = new Rule({ selector, nodes: rule.nodes })
    rule.removeAll()
    rule.append(selectorBlock)
  }
  rule[rootRuleEscapes] = escapes
  rule[rootRuleMergeSel] = escapes ? !escapes('all') : type === 'noop'
}

const hasRootRule = Symbol('hasRootRule')

module.exports = (opts = {}) => {
  let bubble = atruleNames(
    ['media', 'supports', 'layer', 'container'],
    opts.bubble
  )
  let atruleChilds = createFnAtruleChilds(bubble)
  let unwrap = atruleNames(
    [
      'document',
      'font-face',
      'keyframes',
      '-webkit-keyframes',
      '-moz-keyframes'
    ],
    opts.unwrap
  )
  let rootRuleName = (opts.rootRuleName || 'at-root').replace(/^@/, '')
  let preserveEmpty = opts.preserveEmpty

  return {
    postcssPlugin: 'postcss-nested',

    Once(root) {
      root.walkAtRules(rootRuleName, node => {
        normalizeRootRule(node)
        root[hasRootRule] = true
      })
    },

    Rule(rule) {
      let unwrapped = false
      let after = rule
      let copyDeclarations = false
      let declarations = []

      rule.each(child => {
        if (child.type === 'rule') {
          if (declarations.length) {
            after = pickDeclarations(rule.selector, declarations, after)
            declarations = []
          }

          copyDeclarations = true
          unwrapped = true
          child.selectors = mergeSelectors(rule, child)
          after = breakOut(child, after)
        } else if (child.type === 'atrule') {
          if (declarations.length) {
            after = pickDeclarations(rule.selector, declarations, after)
            declarations = []
          }
          if (child.name === rootRuleName) {
            unwrapped = true
            atruleChilds(rule, child, true, child[rootRuleMergeSel])
            after = breakOut(child, after)
          } else if (bubble[child.name]) {
            copyDeclarations = true
            unwrapped = true
            atruleChilds(rule, child, true)
            after = breakOut(child, after)
          } else if (unwrap[child.name]) {
            copyDeclarations = true
            unwrapped = true
            atruleChilds(rule, child, false)
            after = breakOut(child, after)
          } else if (copyDeclarations) {
            declarations.push(child)
          }
        } else if (child.type === 'decl' && copyDeclarations) {
          declarations.push(child)
        }
      })

      if (declarations.length) {
        after = pickDeclarations(rule.selector, declarations, after)
      }

      if (unwrapped && preserveEmpty !== true) {
        rule.raws.semicolon = true
        if (rule.nodes.length === 0) rule.remove()
      }
    },

    RootExit(root) {
      if (root[hasRootRule]) {
        root.walkAtRules(rootRuleName, unwrapRootRule)
        root[hasRootRule] = false
      }
    }
  }
}
module.exports.postcss = true
