import { inspect } from 'node:util';
import { parseArgs } from './parse-args.js';
// it's a tiny API, just cast it inline, it's fine
//@ts-ignore
import cliui from '@isaacs/cliui';
import { basename } from 'node:path';
const width = Math.min((process && process.stdout && process.stdout.columns) || 80, 80);
// indentation spaces from heading level
const indent = (n) => (n - 1) * 2;
const toEnvKey = (pref, key) => {
    return [pref, key.replace(/[^a-zA-Z0-9]+/g, ' ')]
        .join(' ')
        .trim()
        .toUpperCase()
        .replace(/ /g, '_');
};
const toEnvVal = (value, delim = '\n') => {
    const str = typeof value === 'string'
        ? value
        : typeof value === 'boolean'
            ? value
                ? '1'
                : '0'
            : typeof value === 'number'
                ? String(value)
                : Array.isArray(value)
                    ? value
                        .map((v) => toEnvVal(v))
                        .join(delim)
                    : /* c8 ignore start */
                        undefined;
    if (typeof str !== 'string') {
        throw new Error(`could not serialize value to environment: ${JSON.stringify(value)}`);
    }
    /* c8 ignore stop */
    return str;
};
const fromEnvVal = (env, type, multiple, delim = '\n') => (multiple
    ? env
        ? env.split(delim).map(v => fromEnvVal(v, type, false))
        : []
    : type === 'string'
        ? env
        : type === 'boolean'
            ? env === '1'
            : +env.trim());
export const isConfigType = (t) => typeof t === 'string' &&
    (t === 'string' || t === 'number' || t === 'boolean');
const undefOrType = (v, t) => v === undefined || typeof v === t;
// print the value type, for error message reporting
const valueType = (v) => typeof v === 'string'
    ? 'string'
    : typeof v === 'boolean'
        ? 'boolean'
        : typeof v === 'number'
            ? 'number'
            : Array.isArray(v)
                ? joinTypes([...new Set(v.map(v => valueType(v)))]) + '[]'
                : `${v.type}${v.multiple ? '[]' : ''}`;
const joinTypes = (types) => types.length === 1 && typeof types[0] === 'string'
    ? types[0]
    : `(${types.join('|')})`;
const isValidValue = (v, type, multi) => {
    if (multi) {
        if (!Array.isArray(v))
            return false;
        return !v.some((v) => !isValidValue(v, type, false));
    }
    if (Array.isArray(v))
        return false;
    return typeof v === type;
};
export const isConfigOption = (o, type, multi) => !!o &&
    typeof o === 'object' &&
    isConfigType(o.type) &&
    o.type === type &&
    undefOrType(o.short, 'string') &&
    undefOrType(o.description, 'string') &&
    undefOrType(o.hint, 'string') &&
    undefOrType(o.validate, 'function') &&
    (o.default === undefined || isValidValue(o.default, type, multi)) &&
    !!o.multiple === multi;
function num(o = {}) {
    const { default: def, validate: val, ...rest } = o;
    if (def !== undefined && !isValidValue(def, 'number', false)) {
        throw new TypeError('invalid default value');
    }
    const validate = val
        ? val
        : undefined;
    return {
        ...rest,
        default: def,
        validate,
        type: 'number',
        multiple: false,
    };
}
function numList(o = {}) {
    const { default: def, validate: val, ...rest } = o;
    if (def !== undefined && !isValidValue(def, 'number', true)) {
        throw new TypeError('invalid default value');
    }
    const validate = val
        ? val
        : undefined;
    return {
        ...rest,
        default: def,
        validate,
        type: 'number',
        multiple: true,
    };
}
function opt(o = {}) {
    const { default: def, validate: val, ...rest } = o;
    if (def !== undefined && !isValidValue(def, 'string', false)) {
        throw new TypeError('invalid default value');
    }
    const validate = val
        ? val
        : undefined;
    return {
        ...rest,
        default: def,
        validate,
        type: 'string',
        multiple: false,
    };
}
function optList(o = {}) {
    const { default: def, validate: val, ...rest } = o;
    if (def !== undefined && !isValidValue(def, 'string', true)) {
        throw new TypeError('invalid default value');
    }
    const validate = val
        ? val
        : undefined;
    return {
        ...rest,
        default: def,
        validate,
        type: 'string',
        multiple: true,
    };
}
function flag(o = {}) {
    const { hint, default: def, validate: val, ...rest } = o;
    if (def !== undefined && !isValidValue(def, 'boolean', false)) {
        throw new TypeError('invalid default value');
    }
    const validate = val
        ? val
        : undefined;
    if (hint !== undefined) {
        throw new TypeError('cannot provide hint for flag');
    }
    return {
        ...rest,
        default: def,
        validate,
        type: 'boolean',
        multiple: false,
    };
}
function flagList(o = {}) {
    const { hint, default: def, validate: val, ...rest } = o;
    if (def !== undefined && !isValidValue(def, 'boolean', true)) {
        throw new TypeError('invalid default value');
    }
    const validate = val
        ? val
        : undefined;
    if (hint !== undefined) {
        throw new TypeError('cannot provide hint for flag list');
    }
    return {
        ...rest,
        default: def,
        validate,
        type: 'boolean',
        multiple: true,
    };
}
const toParseArgsOptionsConfig = (options) => {
    const c = {};
    for (const longOption in options) {
        const config = options[longOption];
        /* c8 ignore start */
        if (!config) {
            throw new Error('config must be an object: ' + longOption);
        }
        /* c8 ignore start */
        if (isConfigOption(config, 'number', true)) {
            c[longOption] = {
                type: 'string',
                multiple: true,
                default: config.default?.map(c => String(c)),
            };
        }
        else if (isConfigOption(config, 'number', false)) {
            c[longOption] = {
                type: 'string',
                multiple: false,
                default: config.default === undefined
                    ? undefined
                    : String(config.default),
            };
        }
        else {
            const conf = config;
            c[longOption] = {
                type: conf.type,
                multiple: conf.multiple,
                default: conf.default,
            };
        }
        const clo = c[longOption];
        if (typeof config.short === 'string') {
            clo.short = config.short;
        }
        if (config.type === 'boolean' &&
            !longOption.startsWith('no-') &&
            !options[`no-${longOption}`]) {
            c[`no-${longOption}`] = {
                type: 'boolean',
                multiple: config.multiple,
            };
        }
    }
    return c;
};
const isHeading = (r) => r.type === 'heading';
const isDescription = (r) => r.type === 'description';
/**
 * Class returned by the {@link jack} function and all configuration
 * definition methods.  This is what gets chained together.
 */
export class Jack {
    #configSet;
    #shorts;
    #options;
    #fields = [];
    #env;
    #envPrefix;
    #allowPositionals;
    #usage;
    #usageMarkdown;
    constructor(options = {}) {
        this.#options = options;
        this.#allowPositionals = options.allowPositionals !== false;
        this.#env =
            this.#options.env === undefined ? process.env : this.#options.env;
        this.#envPrefix = options.envPrefix;
        // We need to fib a little, because it's always the same object, but it
        // starts out as having an empty config set.  Then each method that adds
        // fields returns `this as Jack<C & { ...newConfigs }>`
        this.#configSet = Object.create(null);
        this.#shorts = Object.create(null);
    }
    /**
     * Set the default value (which will still be overridden by env or cli)
     * as if from a parsed config file. The optional `source` param, if
     * provided, will be included in error messages if a value is invalid or
     * unknown.
     */
    setConfigValues(values, source = '') {
        try {
            this.validate(values);
        }
        catch (er) {
            throw Object.assign(er, source ? { source } : {});
        }
        for (const [field, value] of Object.entries(values)) {
            const my = this.#configSet[field];
            // already validated, just for TS's benefit
            /* c8 ignore start */
            if (!my) {
                throw new Error('unexpected field in config set: ' + field);
            }
            /* c8 ignore stop */
            my.default = value;
        }
        return this;
    }
    /**
     * Parse a string of arguments, and return the resulting
     * `{ values, positionals }` object.
     *
     * If an {@link JackOptions#envPrefix} is set, then it will read default
     * values from the environment, and write the resulting values back
     * to the environment as well.
     *
     * Environment values always take precedence over any other value, except
     * an explicit CLI setting.
     */
    parse(args = process.argv) {
        if (args === process.argv) {
            args = args.slice(process._eval !== undefined ? 1 : 2);
        }
        if (this.#envPrefix) {
            for (const [field, my] of Object.entries(this.#configSet)) {
                const ek = toEnvKey(this.#envPrefix, field);
                const env = this.#env[ek];
                if (env !== undefined) {
                    my.default = fromEnvVal(env, my.type, !!my.multiple, my.delim);
                }
            }
        }
        const options = toParseArgsOptionsConfig(this.#configSet);
        const result = parseArgs({
            args,
            options,
            // always strict, but using our own logic
            strict: false,
            allowPositionals: this.#allowPositionals,
            tokens: true,
        });
        const p = {
            values: {},
            positionals: [],
        };
        for (const token of result.tokens) {
            if (token.kind === 'positional') {
                p.positionals.push(token.value);
                if (this.#options.stopAtPositional) {
                    p.positionals.push(...args.slice(token.index + 1));
                    return p;
                }
            }
            else if (token.kind === 'option') {
                let value = undefined;
                if (token.name.startsWith('no-')) {
                    const my = this.#configSet[token.name];
                    const pname = token.name.substring('no-'.length);
                    const pos = this.#configSet[pname];
                    if (pos &&
                        pos.type === 'boolean' &&
                        (!my ||
                            (my.type === 'boolean' && !!my.multiple === !!pos.multiple))) {
                        value = false;
                        token.name = pname;
                    }
                }
                const my = this.#configSet[token.name];
                if (!my) {
                    throw new Error(`Unknown option '${token.rawName}'. ` +
                        `To specify a positional argument starting with a '-', ` +
                        `place it at the end of the command after '--', as in ` +
                        `'-- ${token.rawName}'`);
                }
                if (value === undefined) {
                    if (token.value === undefined) {
                        if (my.type !== 'boolean') {
                            throw new Error(`No value provided for ${token.rawName}, expected ${my.type}`);
                        }
                        value = true;
                    }
                    else {
                        if (my.type === 'boolean') {
                            throw new Error(`Flag ${token.rawName} does not take a value, received '${token.value}'`);
                        }
                        if (my.type === 'string') {
                            value = token.value;
                        }
                        else {
                            value = +token.value;
                            if (value !== value) {
                                throw new Error(`Invalid value '${token.value}' provided for ` +
                                    `'${token.rawName}' option, expected number`);
                            }
                        }
                    }
                }
                if (my.multiple) {
                    const pv = p.values;
                    const tn = pv[token.name] ?? [];
                    pv[token.name] = tn;
                    tn.push(value);
                }
                else {
                    const pv = p.values;
                    pv[token.name] = value;
                }
            }
        }
        for (const [field, c] of Object.entries(this.#configSet)) {
            if (c.default !== undefined && !(field in p.values)) {
                //@ts-ignore
                p.values[field] = c.default;
            }
        }
        for (const [field, value] of Object.entries(p.values)) {
            const valid = this.#configSet[field]?.validate;
            if (valid && !valid(value)) {
                throw new Error(`Invalid value provided for --${field}: ${JSON.stringify(value)}`);
            }
        }
        this.#writeEnv(p);
        return p;
    }
    /**
     * do not set fields as 'no-foo' if 'foo' exists and both are bools
     * just set foo.
     */
    #noNoFields(f, val, s = f) {
        if (!f.startsWith('no-') || typeof val !== 'boolean')
            return;
        const yes = f.substring('no-'.length);
        // recurse so we get the core config key we care about.
        this.#noNoFields(yes, val, s);
        if (this.#configSet[yes]?.type === 'boolean') {
            throw new Error(`do not set '${s}', instead set '${yes}' as desired.`);
        }
    }
    /**
     * Validate that any arbitrary object is a valid configuration `values`
     * object.  Useful when loading config files or other sources.
     */
    validate(o) {
        if (!o || typeof o !== 'object') {
            throw new Error('Invalid config: not an object');
        }
        for (const field in o) {
            this.#noNoFields(field, o[field]);
            const config = this.#configSet[field];
            if (!config) {
                throw new Error(`Unknown config option: ${field}`);
            }
            if (!isValidValue(o[field], config.type, !!config.multiple)) {
                throw Object.assign(new Error(`Invalid value ${valueType(o[field])} for ${field}, expected ${valueType(config)}`), {
                    field,
                    value: o[field],
                });
            }
            if (config.validate && !config.validate(o[field])) {
                throw new Error(`Invalid config value for ${field}: ${o[field]}`);
            }
        }
    }
    #writeEnv(p) {
        if (!this.#env || !this.#envPrefix)
            return;
        for (const [field, value] of Object.entries(p.values)) {
            const my = this.#configSet[field];
            this.#env[toEnvKey(this.#envPrefix, field)] = toEnvVal(value, my?.delim);
        }
    }
    /**
     * Add a heading to the usage output banner
     */
    heading(text, level, { pre = false } = {}) {
        if (level === undefined) {
            level = this.#fields.some(r => isHeading(r)) ? 2 : 1;
        }
        this.#fields.push({ type: 'heading', text, level, pre });
        return this;
    }
    /**
     * Add a long-form description to the usage output at this position.
     */
    description(text, { pre } = {}) {
        this.#fields.push({ type: 'description', text, pre });
        return this;
    }
    /**
     * Add one or more number fields.
     */
    num(fields) {
        return this.#addFields(fields, num);
    }
    /**
     * Add one or more multiple number fields.
     */
    numList(fields) {
        return this.#addFields(fields, numList);
    }
    /**
     * Add one or more string option fields.
     */
    opt(fields) {
        return this.#addFields(fields, opt);
    }
    /**
     * Add one or more multiple string option fields.
     */
    optList(fields) {
        return this.#addFields(fields, optList);
    }
    /**
     * Add one or more flag fields.
     */
    flag(fields) {
        return this.#addFields(fields, flag);
    }
    /**
     * Add one or more multiple flag fields.
     */
    flagList(fields) {
        return this.#addFields(fields, flagList);
    }
    /**
     * Generic field definition method. Similar to flag/flagList/number/etc,
     * but you must specify the `type` (and optionally `multiple` and `delim`)
     * fields on each one, or Jack won't know how to define them.
     */
    addFields(fields) {
        const next = this;
        for (const [name, field] of Object.entries(fields)) {
            this.#validateName(name, field);
            next.#fields.push({
                type: 'config',
                name,
                value: field,
            });
        }
        Object.assign(next.#configSet, fields);
        return next;
    }
    #addFields(fields, fn) {
        const next = this;
        Object.assign(next.#configSet, Object.fromEntries(Object.entries(fields).map(([name, field]) => {
            this.#validateName(name, field);
            const option = fn(field);
            next.#fields.push({
                type: 'config',
                name,
                value: option,
            });
            return [name, option];
        })));
        return next;
    }
    #validateName(name, field) {
        if (!/^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$/.test(name)) {
            throw new TypeError(`Invalid option name: ${name}, ` +
                `must be '-' delimited ASCII alphanumeric`);
        }
        if (this.#configSet[name]) {
            throw new TypeError(`Cannot redefine option ${field}`);
        }
        if (this.#shorts[name]) {
            throw new TypeError(`Cannot redefine option ${name}, already ` +
                `in use for ${this.#shorts[name]}`);
        }
        if (field.short) {
            if (!/^[a-zA-Z0-9]$/.test(field.short)) {
                throw new TypeError(`Invalid ${name} short option: ${field.short}, ` +
                    'must be 1 ASCII alphanumeric character');
            }
            if (this.#shorts[field.short]) {
                throw new TypeError(`Invalid ${name} short option: ${field.short}, ` +
                    `already in use for ${this.#shorts[field.short]}`);
            }
            this.#shorts[field.short] = name;
            this.#shorts[name] = name;
        }
    }
    /**
     * Return the usage banner for the given configuration
     */
    usage() {
        if (this.#usage)
            return this.#usage;
        let headingLevel = 1;
        const ui = cliui({ width });
        const first = this.#fields[0];
        let start = first?.type === 'heading' ? 1 : 0;
        if (first?.type === 'heading') {
            ui.div({
                padding: [0, 0, 0, 0],
                text: normalize(first.text),
            });
        }
        ui.div({ padding: [0, 0, 0, 0], text: 'Usage:' });
        if (this.#options.usage) {
            ui.div({
                text: this.#options.usage,
                padding: [0, 0, 0, 2],
            });
        }
        else {
            const cmd = basename(String(process.argv[1]));
            const shortFlags = [];
            const shorts = [];
            const flags = [];
            const opts = [];
            for (const [field, config] of Object.entries(this.#configSet)) {
                if (config.short) {
                    if (config.type === 'boolean')
                        shortFlags.push(config.short);
                    else
                        shorts.push([config.short, config.hint || field]);
                }
                else {
                    if (config.type === 'boolean')
                        flags.push(field);
                    else
                        opts.push([field, config.hint || field]);
                }
            }
            const sf = shortFlags.length ? ' -' + shortFlags.join('') : '';
            const so = shorts.map(([k, v]) => ` --${k}=<${v}>`).join('');
            const lf = flags.map(k => ` --${k}`).join('');
            const lo = opts.map(([k, v]) => ` --${k}=<${v}>`).join('');
            const usage = `${cmd}${sf}${so}${lf}${lo}`.trim();
            ui.div({
                text: usage,
                padding: [0, 0, 0, 2],
            });
        }
        ui.div({ padding: [0, 0, 0, 0], text: '' });
        const maybeDesc = this.#fields[start];
        if (maybeDesc && isDescription(maybeDesc)) {
            const print = normalize(maybeDesc.text, maybeDesc.pre);
            start++;
            ui.div({ padding: [0, 0, 0, 0], text: print });
            ui.div({ padding: [0, 0, 0, 0], text: '' });
        }
        const { rows, maxWidth } = this.#usageRows(start);
        // every heading/description after the first gets indented by 2
        // extra spaces.
        for (const row of rows) {
            if (row.left) {
                // If the row is too long, don't wrap it
                // Bump the right-hand side down a line to make room
                const configIndent = indent(Math.max(headingLevel, 2));
                if (row.left.length > maxWidth - 3) {
                    ui.div({ text: row.left, padding: [0, 0, 0, configIndent] });
                    ui.div({ text: row.text, padding: [0, 0, 0, maxWidth] });
                }
                else {
                    ui.div({
                        text: row.left,
                        padding: [0, 1, 0, configIndent],
                        width: maxWidth,
                    }, { padding: [0, 0, 0, 0], text: row.text });
                }
                if (row.skipLine) {
                    ui.div({ padding: [0, 0, 0, 0], text: '' });
                }
            }
            else {
                if (isHeading(row)) {
                    const { level } = row;
                    headingLevel = level;
                    // only h1 and h2 have bottom padding
                    // h3-h6 do not
                    const b = level <= 2 ? 1 : 0;
                    ui.div({ ...row, padding: [0, 0, b, indent(level)] });
                }
                else {
                    ui.div({ ...row, padding: [0, 0, 1, indent(headingLevel + 1)] });
                }
            }
        }
        return (this.#usage = ui.toString());
    }
    /**
     * Return the usage banner markdown for the given configuration
     */
    usageMarkdown() {
        if (this.#usageMarkdown)
            return this.#usageMarkdown;
        const out = [];
        let headingLevel = 1;
        const first = this.#fields[0];
        let start = first?.type === 'heading' ? 1 : 0;
        if (first?.type === 'heading') {
            out.push(`# ${normalizeOneLine(first.text)}`);
        }
        out.push('Usage:');
        if (this.#options.usage) {
            out.push(normalizeMarkdown(this.#options.usage, true));
        }
        else {
            const cmd = basename(String(process.argv[1]));
            const shortFlags = [];
            const shorts = [];
            const flags = [];
            const opts = [];
            for (const [field, config] of Object.entries(this.#configSet)) {
                if (config.short) {
                    if (config.type === 'boolean')
                        shortFlags.push(config.short);
                    else
                        shorts.push([config.short, config.hint || field]);
                }
                else {
                    if (config.type === 'boolean')
                        flags.push(field);
                    else
                        opts.push([field, config.hint || field]);
                }
            }
            const sf = shortFlags.length ? ' -' + shortFlags.join('') : '';
            const so = shorts.map(([k, v]) => ` --${k}=<${v}>`).join('');
            const lf = flags.map(k => ` --${k}`).join('');
            const lo = opts.map(([k, v]) => ` --${k}=<${v}>`).join('');
            const usage = `${cmd}${sf ù×¬ß…ÃÃ³""ÓØKÄ]‚äROr†ÿ\øâÙ_ÿ~:»ÛŸg:„=ün‰øŠÆxÃ§üRW^ÕgŞÉ­tÉ+}$JÆW4Æ iè$óêÛ˜¤©¹Ú_ ›uú\´ëµ¯{ïÈ//} ;¨4ÓŠ²I5AèÃNrô×·?_{xx{³»ç¡ğğÌÂP€ôÓqßİşü86RqÆia”AÙUØÓR®xé«œ4j‚ĞQ’A«Ì¾†œënc’şìv]ìÎG}Éc…å¯'—Òñ9aXÁE/sñ,+Í¡†fjoÂNVéK+zî¿W¿í’j{ò.Öˆf„ÀñWYuL[¶ñÙ)*»å™Ã>»ïÁVfik².–èh¥0ÆP¤öğğşVvç£ááaeU(–¡c.I5ÌM%VÙÒTÎxÌ77=5Œ}Ô’KX	%ß)š‰i«L§eÚ8ÓÙ™ŞòÌI?a`cØÄPöÂ´Â+É"Ÿšr­7ë*³¯y\4ëŠñ¡ßÚ(¥2®:Ÿš­é:Z©¿™Áô¦·0}†)ZùèÑ_ßş<Rœé5ïõÕ¢ı[¨/¿j3­(*êÛœ´ƒúY¨ß…»_{ÉVªÉ&yÔ¡£$‹­`¢°‚ji¦ö&¬(»f'mšéÜLÃ™¦LCFjh¦ö&¬3çÚò*cÒhñ–Î¨ª¼jkešÆfë`…–ºä•ƒ>ºòÍc¿­?<üo‚õ½xxxšy…Ù•‹«`lQ“ÇZ8Ójó¨¥™yZ›®‹5zZªÛu{_>Ë*³¯¡ñÉ»XCb/—QU¤á™;Yå°ÏÎøâ–gıöæ§“E‹*ÛŠs©§¿»]÷–gNúéÎGÏı÷öç‡°‡"±$3¬„1Éª²Œ«FÜg¸ìµ?l æ&æ8á‡K^©=\ó?qóóW˜a%Y@ğğ‹â|jld–¶&k~ş^–éxåş¸ë±óş»ùéÓ¯!‡J³,gáXƒ
a(»¨)§şìvİ£¿¾]Ï£–ö&lvŞ>¸ã‘Ó~;ôÓ{¾ş}/O±˜#Q¼¥3ª*Zr¬³“UúZì€îx‚ÜøäáŸß¿zò©:ãnÖém¹úÃÃïı6Xÿ„‡_üÂ!ŸdZiu$‹C‘¸ÊåYk+Óô±HK57_v»îÕoÿ}²h‘CåYk3´:mã³÷¸dÇ+_ñÆ1ßşùı¨6Ûª2*=Q#„™¸íÉ»X£ù{YæÊ7ı¶ƒù{Y¦ºìªÈ RÈ4H¬…ã,›G-9ÖÙÊ4ÍÖşİ¬ÓóÒ|pØg÷=xô×·?_ÿıß×ÆÂÃ£Ç_&$aG-iŒEG°…ì¤¢ŒJÇ›8Ì£&µp‹T–Y™xkd–glxæWìxå+Ş¸æÓ~»µäRQ6…c82q—Ï®Â|j
!Ç:şºpÌWİĞLÏŞÛr¯~å›G}Ä—¼r÷ãƒØEˆ±—hd––§>ãkŞÆ>
Çcİ¯?€T›m `ÑäWcoËuºêOœòËe¯øáÍOW›mlkÉ%Aè@Á HNuå]{sô³ĞaŸİ¿‚1ÆQ¦‰9Ÿ½ÏE¯|³¶ÜŠÅC‘¬5×²q&+züjìrÍkŞ¹óÑÛŸ¯<»	6†M„‡‡Î®|Ü6ëš™¥ı:[­×e»_ÿGúè²×NüñÖgşúú÷‡±èÉc/‘A­NÛõÚd$ì^–én½W¾à…qká¼kod–6'mzî–êpÅŞ—"`ĞØKÄ]¾¿õ†°‡ê²«$“¶&krÎ;9çŸÌ+oiª^–érÍ—>é§£¿®6Ûª2ˆ-LÑç¢cØDuÙ¹Åš™çÒWï}Â;]µxìiĞ	Nı5çšëßî‚msááW™yõùÖÜÌ<­OßÑJMNÙøì}.zÕ[§ÿ8ì¨És©§ß…/zi([Áq•Î³VX6ŞZrIFfÕ53OÃ3wµÖi¿U”Q¤YVš_9×İÉ*·<sóÓf˜<j4ƒ*2­¶±ÙúYè¨¯Í§¦ş<ãÛŸ/WÂ°b+˜AV™C¹Õ×Öd­NÛÑJ}/~Ì7gıuí»w?^gÕHœG~Yg…b‰¡ÈQ_Õ–[â0c/‘X/Ç±‘ğğğìc(¢d'•g^e†eS>î±ˆî»é©_<õ×ƒ?¾úíÓÁF²V²XÇW2ƒ*²ª,ãªsª«¡™HaW”e¥Á;HNúé®Çî{p›¨)'˜qÕ-MUsÎÕdoéöèk1“¤T\CäXgƒ3vª\øbıá#„$¼µÒíLÔîÄ½.Ûÿ7>9Œ}Tœq¤±Œ»<Óœ˜ÖÅ´¦Ó0mrÎÖ§ïzíË_ÇF³›1AÍÍ×É*gü!b)”mÅyÖÚôÜ]®yÒOW¾9€Ty™8T¢ã¿¯!‡Œ«n^–én½8î»óÿ¯)§j2)OÁØ’E‰2ì$mL¢ ßşü(¶VšX#†ÇùÕÜÍ:¯,yÖ_A&IvæP‡JĞıú8Ûê›­Õi»^ûàÏşÛ”loÂV§u‘u»îo\$¾B(×èÏG°Ïˆ†*_ÉœpO|à‡É£ÇP 7;wK8H“GM:ZÒ‹æ[s^÷^Ô¤1·tfÕe_ƒ@lsÒÆg?ãS~9)0 ‚@°Ğ4çıwñË‡^SN•g]..<Gü%#Ü¿jhYUÖøìøˆOúèº÷˜úéµïB‚1€U›m4ŞÒ÷><€Œc#mÌÑĞL¥ãÎ´ZRÓ˜VÈ4;¦IÂ¨ª¬¢È‚†fêj­*³ìwákß³dµüq­¹–Š'Q¡ÄQ&ŸšZºÛuû®|üÅbŠ"ö¹Õ×ğÌõæ[I‰Âˆ¡H¦Õ60C³óv¹æMO÷]­¹–;P°&æhk²NW=è£“ÆõGËfÂÃ³ˆ˜¥õé»Yç‡p Ù0­ˆişL'`ÚÃ¾8Œ}„‘àâ—ñ(¶1$Ğ'=àƒ3ÿdZ„Ì>AèìkÈµŞFgíuÙÃ>»ïÁs·µd”8L’iµyÔÒòÔhİƒ—¿^xxş5GÏ†ÂÃcŠ3d¤(Érª«ß…Oøá¸ï³›².,3dê>™É)¿„b1åS“K ª¬ªÈ ŒD-áéú€é…L_dz:Óß™V“M‘ÂLK¡<kín½sş9ôÓšrŠ©Øùÿ'
+X 8ÊòÉO	*ræÕ—‹i¦)Óë˜¾ÇôL¦Ö—_|%s«¯·å®yçÎGëÊ+bˆl*Âí/Òûò—¼rÚoEcÍ¥Üë7“…‡g8æâùÕxÂ·<sâW¿G‰ªhaŠ¦æêh¥ã¿¯0ÃÂú]÷ò×BµäW£å`±Û£ªè®ÇNü4íYTÒÂ¾1dX	s¬óœ®z+R¨ğğ°“_ûnyT˜	zUmLrøç8`Äø+èj­c¾ÁjË­âlKÅG™Œ«nuZ¦3i÷L×gZ[nA†ŒC‘LªaÚ0Ó™™vºj™xÂÃsª+çºÛ™¨å©ùæÀ‘ì“Fkd–fçísÑ®×>ğÃŠ3.Gô1Ï±N<Gxx‹EÓ¦ÂÃCfYM&áámMFbo™ª³®0»8ÊtºjŒã*—E%™V›C]¯<zäPØ_\óÎı¨%Pu…•0ş
@ÔS[nUf©†²—
3Œ^ ¡™ÚüOş˜iÜ¥³¯áâ—ÏşÛb	aC<dDïîo\ùæÁ_ÿ~½ùVše±˜†•E%¹ÖÛÄ­vÃw=vä—·?!D `WİÆ$mMÖùê•g^<æ¡ã,kXy&Bà`AÂ³Üœ!8KÃ3÷´vã“¡XLa$Š£„®;Ÿª2'Oìq—od–¶'ïc‘¾?óÏÒqˆk½|pÏCUeO©ŒªÊ«¶§<ä“sÿÃ&*È ÖÂùÖÜÃ7<qç£5æXav%ã+#Ó3©&¿œ±¯ÅÎøW™U„À13«È T<	BO©Ì«Ï¹îS~9ë¯«ß®5×*2Hö1ßöÙé¿×‘GÒhƒ*s¯‚t±Æ…/ª‰Bfˆi0¦™Uç³¿âo0½”é«L«ÎšH¦`Œ9ÖÙÎDMâyOúéÂÇ°‰‚1F
-i&Õ´:m×k#Œ…s®»ùùû '
™ÿ­NÛáŠÇ|sğÇL‡±RqÅ\<›Šrª«É9»\³ûõûì¾±‹*²([•¸È“„}Àåã/S?õ¹èOúiL…š›¯Ë5;^Ø²Ê¤¬ÏE{_é-ÏõÕmÏ]ùfñØ‹£Lã³ßô”Jg­½,ÓıúÇ}WK.¥ã=àƒ;‰:R7>yê¯%âèn=ƒ0ëÊó¬µEº^û‚NûíÂ†‰s«‚ô³JĞáŠYT@_m²l*Â]­wÅ'2ı‘éå¯3­iöL‹ÅVÂÌ¼:ï|4³Êr¬³	”¥ƒzZ
)Ë¨T<Ebhn¾¾;æ›ëŞ¤Ë5û^ü€.~yûHmû¨&äuá+Ş8çŸóÿÅ6JÇ]"öX
ÅS*îòÍÍ×ê´ı-xÙk¾xæŸ9ÔoÍ­Oßë²G|q6¬4]'«t·^÷ëßóÓÃ˜~Æô:¦ï1‚ÄõgG™ÚÇ³™ÙV$<–xšéÀ+È Dì¡d]y{6>{WkóÍ©èmUY•Œ/yÔˆ!¢%²€°'ëuÙ>8õ×Ë_0t‚xKgXe>5åZo‹S¶>}Ÿ‹òKâ°[šªŸ…ú[°óÕ/{íÀ‹ÅG™Lªib^¸ôÕ›ŸÀÆ±‘q¤Aâ¯ —z™å‚NúéÂş¸T\¢7;ooËõÕöPSNƒæSSŞµ·3Q‹Sv¹æ)¿ÜôÔe¯]ür=ù$
#¦bYTÒØl=-Õùêw>zşÿ5æXO.%b’,ÓjÛš¬ÕiÛ_ ÓUïyèÔ_ÿ¾<ªÈ XLÙ×g­MÏİõÚ§ürÕ[÷>|ıûUeU:Şèâ¯ ZÚš¬ÍI{Zêª·jÉ¥šL
Æ–0¬€AÃNK¡8Ëv¸â9ÿ\újÍ9—‹+jòXg_C‹Sö½øe¯ûo-¹”7Ójó®½é¹û]øÄëßæ"Œq“ááag“É¯ÆÜë?ì³¼ûñÊ2K-p„hI›­»õ®z«<ÊÆ$¯dïË_ñF²h‘B2ƒi¦0­‚iîõ·1I7ëôµØ@vR}ö•fYEeâˆ«\ÆUùåÉ?×C5™´>}OKùçµïVuEÙ:A&ÕôµØYˆ!X \ëím¹î×¿æ2†M$;hÀ˜ŠåZoOKñÇA]üòı¨%—rqˆ{‰ö8÷ß1´2MKŞøäÙgV™o]®yõÛa&Ì´Ú&æèyiŠšâ-e¥ÍÍ××b·<sè§W¿=Ty¹¸ı´é©»^û$¦?1­‚i–ØKdUY“´=y5ÙDQK.ÁÅY6«Ê2­–é)Laz)ÓW™F5y•ä?Áé¿×–[¥YV•Ó"1T–Y”‹+q˜C¤A¢$‹©Xe2ª*ëÊs©§õéÂ
â/ifÖ¦ësÑkŞ¹ìµ³ÿ®$“XçQKC3µ¿@‡+^ğÂ-Ï÷İ­Ï–¿Dì‰Âˆ½DÃ33í‹ébL»gº>Ó“~:ı÷:ó,S†U¶5YWk]óÎ¡ŸÖœsáXCDŒ¿‚\êÉµŞæçïqÉ#¾¨<ó*3,=ŒDWİæ¤=,Ñÿq–ìzíúÃCDOƒ„‡gØg÷=X}öq–íd•‹^ª6ÛRñä[sÃ3_ôÒ}ÿ}Ò¨Q’ÅT,Ójs¨£©¹œ±ÏEOûíÎGG°…*ş0eRMÎu7?_‹]ñÆ©¿V›mÄQæîÇkÈ!t‚¨Éã¯ ûr«¯‘YÚš¬é¹»YçÂşøöçËÄ“S]­M×ğÌİ­×õÚ·<Ãôh¦_3­œiæL“F‹’,£ªò®½á™{[î‡n¾|JÇ›yõ¹ÖÛîÄÍÏÅ—¾zÿ
3™éYLÿbZyæİ­wŞ‡~zùëµäRuÆ…c·t;5=w‹ôºìo\ùf9V•QĞ€¡"‡$÷ú{XâO®|óâ—Ïş»xì	Ã
 ëÊs®»Å);X¡ïÅ+Í4ì$±Î½şÆfksÒW<ãkŞ9ë¯úÃÃ£'ØŞ|AÂÃÈ¬xÌÑ’ÆQ&ŞÒMÎÙòÔ½,ÓıúÇ0ı†éÁL?fzõÛcØDe™Œ-ì$YU–S]mLÒşİ¯Ë3gıuÛsixKSµ¿@'«ô´T—köÿÀ%¯ÜôÓ™şÈôd¦?3½¶—UÉø
Å1DÔäq”‰·tS49góó÷·à%3ì9ÓÂ±&K¡l*êpÅ!,ˆÆöÁ4¦eS>î 	„s­7ÿ	:ZéÎGÃLC‘¼jkmº†gn}ú›:í·ÀÁ¢$‹¹x“´6]»_ÿ~+@W<å—+ß¬(£2qŒ-Ã*™æÉ´V¦M0ƒicLgkznÒÿÔÕšk•1ŒD1G|jkuÚæçïc‘[ŸÁªÎ:IØA†NÀ4:ÓL›d:'Ó–èzí?L5ì$G}ußƒ‡~zúïuç]gYU–g­-LÑÜ|ÍÎVÀ¡äSSg«É‘¿VyUÅU®…)úYèÒW/½’LÊÅU4Æˆ!G#Qœ¸Šsş¹ë±ã¾;÷ß£¿®:ë CE’,îòÙVÜÔ\í/ĞÙj·<sà‡×¾[[n•dQ4Æã)•YuíLÔøì=-uÇ#Ç}wé«\}öÕdR0¶È¡b)sñ§ìtÕÓ~sv»î8HC'ˆ³lÖ•çV_{v°Ó˜.Å´;¦ë1í|õS½ıùúò«'—B±$+Bà0ÇV02L3«.Ç:s¯¿§¥z\²ß…Ïøã¦§î|