"use strict";Object.defineProperty(exports, "__esModule", {value: true});/* eslint max-len: 0 */

// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts ‚Äî that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser











var _flow = require('../plugins/flow');
var _index = require('../plugins/jsx/index');
var _types = require('../plugins/types');









var _typescript = require('../plugins/typescript');












var _index3 = require('../tokenizer/index');
var _keywords = require('../tokenizer/keywords');
var _state = require('../tokenizer/state');
var _types3 = require('../tokenizer/types');
var _charcodes = require('../util/charcodes');
var _identifier = require('../util/identifier');
var _base = require('./base');






var _lval = require('./lval');







var _statement = require('./statement');









var _util = require('./util');

 class StopState {
  
  constructor(stop) {
    this.stop = stop;
  }
} exports.StopState = StopState;

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function (s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.
 function parseExpression(noIn = false) {
  parseMaybeAssign(noIn);
  if (_index3.match.call(void 0, _types3.TokenType.comma)) {
    while (_index3.eat.call(void 0, _types3.TokenType.comma)) {
      parseMaybeAssign(noIn);
    }
  }
} exports.parseExpression = parseExpression;

/**
 * noIn is used when parsing a for loop so that we don't interpret a following "in" as the binary
 * operatior.
 * isWithinParens is used to indicate that we're parsing something that might be a comma expression
 * or might be an arrow function or might be a Flow type assertion (which requires explicit parens).
 * In these cases, we should allow : and ?: after the initial "left" part.
 */
 function parseMaybeAssign(noIn = false, isWithinParens = false) {
  if (_base.isTypeScriptEnabled) {
    return _typescript.tsParseMaybeAssign.call(void 0, noIn, isWithinParens);
  } else if (_base.isFlowEnabled) {
    return _flow.flowParseMaybeAssign.call(void 0, noIn, isWithinParens);
  } else {
    return baseParseMaybeAssign(noIn, isWithinParens);
  }
} exports.parseMaybeAssign = parseMaybeAssign;

// Parse an assignment expression. This includes applications of
// operators like `+=`.
// Returns true if the expression was an arrow function.
 function baseParseMaybeAssign(noIn, isWithinParens) {
  if (_index3.match.call(void 0, _types3.TokenType._yield)) {
    parseYield();
    return false;
  }

  if (_index3.match.call(void 0, _types3.TokenType.parenL) || _index3.match.call(void 0, _types3.TokenType.name) || _index3.match.call(void 0, _types3.TokenType._yield)) {
    _base.state.potentialArrowAt = _base.state.start;
  }

  const wasArrow = parseMaybeConditional(noIn);
  if (isWithinParens) {
    parseParenItem();
  }
  if (_base.state.type & _types3.TokenType.IS_ASSIGN) {
    _index3.next.call(void 0, );
    parseMaybeAssign(noIn);
    return false;
  }
  return wasArrow;
} exports.baseParseMaybeAssign = baseParseMaybeAssign;

// Parse a ternary conditional (`?:`) operator.
// Returns true if the expression was an arrow function.
function parseMaybeConditional(noIn) {
  const wasArrow = parseExprOps(noIn);
  if (wasArrow) {
    return true;
  }
  parseConditional(noIn);
  return false;
}

function parseConditional(noIn) {
  if (_base.isTypeScriptEnabled || _base.isFlowEnabled) {
    _types.typedParseConditional.call(void 0, noIn);
  } else {
    baseParseConditional(noIn);
  }
}

 function baseParseConditional(noIn) {
  if (_index3.eat.call(void 0, _types3.TokenType.question)) {
    parseMaybeAssign();
    _util.expect.call(void 0, _types3.TokenType.colon);
    parseMaybeAssign(noIn);
  }
} exports.baseParseConditional = baseParseConditional;

// Start the precedence parser.
// Returns true if this was an arrow function
function parseExprOps(noIn) {
  const startTokenIndex = _base.state.tokens.length;
  const wasArrow = parseMaybeUnary();
  if (wasArrow) {
    return true;
  }
  parseExprOp(startTokenIndex, -1, noIn);
  return false;
}

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.
function parseExprOp(startTokenIndex, minPrec, noIn) {
  if (
    _base.isTypeScriptEnabled &&
    (_types3.TokenType._in & _types3.TokenType.PRECEDENCE_MASK) > minPrec &&
    !_util.hasPrecedingLineBreak.call(void 0, ) &&
    (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._as) || _util.eatContextual.call(void 0, _keywords.ContextualKeyword._satisfies))
  ) {
    const oldIsType = _index3.pushTypeContext.call(void 0, 1);
    _typescript.tsParseType.call(void 0, );
    _index3.popTypeContext.call(void 0, oldIsType);
    _index3.rescan_gt.call(void 0, );
    parseExprOp(startTokenIndex, minPrec, noIn);
    return;
  }

  const prec = _base.state.type & _types3.TokenType.PRECEDENCE_MASK;
  if (prec > 0 && (!noIn || !_index3.match.call(void 0, _types3.TokenType._in))) {
    if (prec > minPrec) {
      const op = _base.state.type;
      _index3.next.call(void 0, );
      if (op === _types3.TokenType.nullishCoalescing) {
        _base.state.tokens[_base.state.tokens.length - 1].nullishStartIndex = startTokenIndex;
      }

      const rhsStartTokenIndex = _base.state.tokens.length;
      parseMaybeUnary();
      // Extend the right operand of this operator if possible.
      parseExprOp(rhsStartTokenIndex, op & _types3.TokenType.IS_RIGHT_ASSOCIATIVE ? prec - 1 : prec, noIn);
      if (op === _types3.TokenType.nullishCoalescing) {
        _base.state.tokens[startTokenIndex].numNullishCoalesceStarts++;
        _base.state.tokens[_base.state.tokens.length - 1].numNullishCoalesceEnds++;
      }
      // Continue with any future operator holding this expression as the left operand.
      parseExprOp(startTokenIndex, minPrec, noIn);
    }
  }
}

// Parse unary operators, both prefix and postfix.
// Returns true if this was an arrow function.
 function parseMaybeUnary() {
  if (_base.isTypeScriptEnabled && !_base.isJSXEnabled && _index3.eat.call(void 0, _types3.TokenType.lessThan)) {
    _typescript.tsParseTypeAssertion.call(void 0, );
    return false;
  }
  if (
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._module) &&
    _index3.lookaheadCharCode.call(void 0, ) === _charcodes.charCodes.leftCurlyBrace &&
    !_util.hasFollowingLineBreak.call(void 0, )
  ) {
    parseModuleExpression();
    return false;
  }
  if (_base.state.type & _types3.TokenType.IS_PREFIX) {
    _index3.next.call(void 0, );
    parseMaybeUnary();
    return false;
  }

  const wasArrow = parseExprSubscripts();
  if (wasArrow) {
    return true;
  }
  while (_base.state.type & _types3.TokenType.IS_POSTFIX && !_util.canInsertSemicolon.call(void 0, )) {
    // The tokenizer calls everything a preincrement, so make it a postincrement when
    // we see it in that context.
    if (_base.state.type === _types3.TokenType.preIncDec) {
      _base.state.type = _types3.TokenType.postIncDec;
    }
    _index3.next.call(void 0, );
  }
  return false;
} exports.parseMaybeUnary = parseMaybeUnary;

// Parse call, dot, and `[]`-subscript expressions.
// Returns true if this was an arrow function.
 function parseExprSubscripts() {
  const startTokenIndex = _base.state.tokens.length;
  const wasArrow = parseExprAtom();
  if (wasArrow) {
    return true;
  }
  parseSubscripts(startTokenIndex);
  // If there was any optional chain operation, the start token would be marked
  // as such, so also mark the end now.
  if (_base.state.tokens.length > startTokenIndex && _base.state.tokens[startTokenIndex].isOptionalChainStart) {
    _base.state.tokens[_base.state.tokens.length - 1].isOptionalChainEnd = true;
  }
  return false;
} exports.parseExprSubscripts = parseExprSubscripts;

function parseSubscripts(startTokenIndex, noCalls = false) {
  if (_base.isFlowEnabled) {
    _flow.flowParseSubscripts.call(void 0, startTokenIndex, noCalls);
  } else {
    baseParseSubscripts(startTokenIndex, noCalls);
  }
}

 function baseParseSubscripts(startTokenIndex, noCalls = false) {
  const stopState = new StopState(false);
  do {
    parseSubscript(startTokenIndex, noCalls, stopState);
  } while (!stopState.stop && !_base.state.error);
} exports.baseParseSubscripts = baseParseSubscripts;

function parseSubscript(startTokenIndex, noCalls, stopState) {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsParseSubscript.call(void 0, startTokenIndex, noCalls, stopState);
  } else if (_base.isFlowEnabled) {
    _flow.flowParseSubscript.call(void 0, startTokenIndex, noCalls, stopState);
  } else {
    baseParseSubscript(startTokenIndex, noCalls, stopState);
  }
}

/** Set 'state.stop = true' to indicate that we should stop parsing subscripts. */
 function baseParseSubscript(
  startTokenIndex,
  noCalls,
  stopState,
) {
  if (!noCalls && _index3.eat.call(void 0, _types3.TokenType.doubleColon)) {
    parseNoCallExpr();
    stopState.stop = true;
    // Propagate startTokenIndex so that `a::b?.()` will keep `a` as the first token. We may want
    // to revisit this in the future when fully supporting bind syntax.
    parseSubscripts(startTokenIndex, noCalls);
  } else if (_index3.match.call(void 0, _types3.TokenType.questionDot)) {
    _base.state.tokens[startTokenIndex].isOptionalChainStart = true;
    if (noCalls && _index3.lookaheadType.call(void 0, ) === _types3.TokenType.parenL) {
      stopState.stop = true;
      return;
    }
    _index3.next.call(void 0, );
    _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;

    if (_index3.eat.call(void 0, _types3.TokenType.bracketL)) {
      parseExpression();
      _util.expect.call(void 0, _types3.TokenType.bracketR);
    } else if (_index3.eat.call(void 0, _types3.TokenType.parenL)) {
      parseCallExpressionArguments();
    } else {
      parseMaybePrivateName();
    }
  } else if (_index3.eat.call(void 0, _types3.TokenType.dot)) {
    _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
    parseMaybePrivateName();
  } else if (_index3.eat.call(void 0, _types3.TokenType.bracketL)) {
    _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
    parseExpression();
    _util.expect.call(void 0, _types3.TokenType.bracketR);
  } else if (!noCalls && _index3.match.call(void 0, _types3.TokenType.parenL)) {
    if (atPossibleAsync()) {
      // We see "async", but it's possible it's a usage of the name "async". Parse as if it's a
      // function call, and if we see an arrow later, backtrack and re-parse as a parameter list.
      const snapshot = _base.state.snapshot();
      const asyncStartTokenIndex = _base.state.tokens.length;
      _index3.next.call(void 0, );
      _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;

      const callContextId = _base.getNextContextId.call(void 0, );

      _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;
      parseCallExpressionArguments();
      _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;

      if (shouldParseAsyncArrow()) {
        // We hit an arrow, so backtrack and start again parsing function parameters.
        _base.state.restoreFromSnapshot(snapshot);
        stopState.stop = true;
        _base.state.scopeDepth++;

        _statement.parseFunctionParams.call(void 0, );
        parseAsyncArrowFromCallExpression(asyncStartTokenIndex);
      }
    } else {
      _index3.next.call(void 0, );
      _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
      const callContextId = _base.getNextContextId.call(void 0, );
      _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;
      parseCallExpressionArguments();
      _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;
    }
  } else if (_index3.match.call(void 0, _types3.TokenType.backQuote)) {
    // Tagged template expression.
    parseTemplate();
  } else {
    stopState.stop = true;
  }
} exports.baseParseSubscript = baseParseSubscript;

 function atPossibleAsync() {
  // This was made less strict than the original version to avoid passing around nodes, but it
  // should be safe to have rare false positives here.
  return (
    _base.state.tokens[_base.state.tokens.length - 1].contextualKeyword === _keywords.ContextualKeyword._async &&
    !_util.canInsertSemicolon.call(void 0, )
  );
} exports.atPossibleAsync = atPossibleAsync;

 function parseCallExpressionArguments() {
  let first = true;
  while (!_index3.eat.call(void 0, _types3.TokenType.parenR) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      _util.expect.call(void 0, _types3.TokenType.comma);
      if (_index3.eat.call(void 0, _types3.TokenType.parenR)) {
        break;
      }
    }

    parseExprListItem(false);
  }
} exports.parseCallExpressionArguments = parseCallExpressionArguments;

function shouldParseAsyncArrow() {
  return _index3.match.call(void 0, _types3.TokenType.colon) || _index3.match.call(void 0, _types3.TokenType.arrow);
}

function parseAsyncArrowFromCallExpression(startTokenIndex) {
  if (_base.isTypeScriptEnabled) {
    _typescript.tsStartParseAsyncArrowFromCallExpression.call(void 0, );
  } else if (_base.isFlowEnabled) {
    _flow.flowStartParseAsyncArrowFromCallExpression.call(void 0, );
  }
  _util.expect.call(void 0, _types3.TokenType.arrow);
  parseArrowExpression(startTokenIndex);
}

// Parse a no-call expression (like argument of `new` or `::` operators).

function parseNoCallExpr() {
  const startTokenIndex = _base.state.tokens.length;
  parseExprAtom();
  parseSubscripts(startTokenIndex, true);
}

// Parse an atomic expression ‚Äî either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.
// Returns true if the parsed expression was an arrow function.
 function parseExprAtom() {
  if (_index3.eat.call(void 0, _types3.TokenType.modulo)) {
    // V8 intrinsic expression. Just parse the identifier, and the function invocation is parsed
    // naturally.
    parseIdentifier();
    return false;
  }

  if (_index3.match.call(void 0, _types3.TokenType.jsxText) || _index3.match.call(void 0, _types3.TokenType.jsxEmptyText)) {
    parseLiteral();
    return false;
  } else if (_index3.match.call(void 0, _types3.TokenType.lessThan) && _base.isJSXEnabled) {
    _base.state.type = _types3.TokenType.jsxTagStart;
    _index.jsxParseElement.call(void 0, );
    _index3.next.call(void 0, );
    return false;
  }

  const canBeArrow = _base.state.potentialArrowAt === _base.state.start;
  switch (_base.state.type) {
    case _types3.TokenType.slash:
    case _types3.TokenType.assign:
      _index3.retokenizeSlashAsRegex.call(void 0, );
    // Fall through.

    case _types3.TokenType._super:
    case _types3.TokenType._this:
    case _types3.TokenType.regexp:
    case _types3.TokenType.num:
    case _types3.TokenType.bigint:
    case _types3.TokenType.decimal:
    case _types3.TokenType.string:
    case _types3.TokenType._null:
    case _types3.TokenType._true:
    case _types3.TokenType._false:
      _index3.next.call(void 0, );
      return false;

    case _types3.TokenType._import:
      _index3.next.call(void 0, );
      if (_index3.match.call(void 0, _types3.TokenType.dot)) {
        // import.meta
        _base.state.tokens[_base.state.tokens.length - 1].type = _types3.TokenType.name;
        _index3.next.call(void 0, );
        parseIdentifier();
      }
      return false;

    case _types3.TokenType.name: {
      const startTokenIndex = _base.state.tokens.length;
      const functionStart = _base.state.start;
      const contextualKeyword = _base.state.contextualKeyword;
      parseIdentifier();
      if (contextualKeyword === _keywords.ContextualKeyword._await) {
        parseAwait();
        return false;
      } else if (
        contextualKeyword === _keywords.ContextualKeyword._async &&
        _index3.match.call(void 0, _types3.TokenType._function) &&
        !_util.canInsertSemicolon.call(void 0, )
      ) {
        _index3.next.call(void 0, );
        _statement.parseFunction.call(void 0, functionStart, false);
        return false;
      } else if (
        canBeArrow &&
        contextualKeyword === _keywords.ContextualKeyword._async &&
        !_util.canInsertSemicolon.call(void 0, ) &&
        _index3.match.call(void 0, _types3.TokenType.name)
      ) {
        _base.state.scopeDepth++;
        _lval.parseBindingIdentifier.call(void 0, false);
        _util.expect.call(void 0, _types3.TokenType.arrow);
        // let foo = async bar => {};
        parseArrowExpression(startTokenIndex);
        return true;
      } else if (_index3.match.call(void 0, _types3.TokenType._do) && !_util.canInsertSemicolon.call(void 0, )) {
        _index3.next.call(void 0, );
        _statement.parseBlock.call(void 0, );
        return false;
      }

      if (canBeArrow && !_util.canInsertSemicolon.call(void 0, ) && _index3.match.call(void 0, _types3.TokenType.arrow)) {
        _base.state.scopeDepth++;
        _lval.markPriorBindingIdentifier.call(void 0, false);
        _util.expect.call(void 0, _types3.TokenType.arrow);
        parseArrowExpression(startTokenIndex);
        return true;
      }

      _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index3.IdentifierRole.Access;
      return false;
    }

    case _types3.TokenType._do: {
      _index3.next.call(void 0, );
      _statement.parseBlock.call(void 0, );
      return false;
    }

    case _types3.TokenType.parenL: {
      const wasArrow = parseParenAndDistinguishExpression(canBeArrow);
      return wasArrow;
    }

    case _types3.TokenType.bracketL:
      _index3.next.call(void 0, );
      parseExprList(_types3.TokenType.bracketR, true);
      return false;

    case _types3.TokenType.braceL:
      parseObj(false, false);
      return false;

    case _types3.TokenType._function:
      parseFunctionExpression();
      return false;

    case _types3.TokenType.at:
      _statement.parseDecorators.call(void 0, );
    // Fall through.

    case _types3.TokenType._class:
      _statement.parseClass.call(void 0, false);
      return false;

    case _types3.TokenType._new:
      parseNew();
      return false;

    case _types3.TokenType.backQuote:
      parseTemplate();
      return false;

    case _types3.TokenType.doubleColon: {
      _index3.next.call(void 0, );
      parseNoCallExpr();
      return false;
    }

    case _types3.TokenType.hash: {
      const code = _index3.lookaheadCharCode.call(void 0, );
      if (_identifier.IS_IDENTIFIER_START[code] || code === _charcodes.charCodes.backslash) {
        parseMaybePrivateName();
      } else {
        _index3.next.call(void 0, );
      }
      // Smart pipeline topic reference.
      return false;
    }

    default:
      _util.unexpected.call(void 0, );
      return false;
  }
} exports.parseExprAtom = parseExprAtom;

function parseMaybePrivateName() {
  _index3.eat.call(void 0, _types3.TokenType.hash);
  parseIdentifier();
}

function parseFunctionExpression() {
  const functionStart = _base.state.start;
  parseIdentifier();
  if (_index3.eat.call(void 0, _types3.TokenType.dot)) {
    // function.sent
    parseIdentifier();
  }
  _statement.parseFunction.call(void 0, functionStart, false);
}

 function parseLiteral() {
  _index3.next.call(void 0, );
} exports.parseLiteral = parseLiteral;

 function parseParenExpression() {
  _util.expect.call(void 0, _types3.TokenType.parenL);
  parseExpression();
  _util.expect.call(void 0, _types3.TokenType.parenR);
} exports.parseParenExpression = parseParenExpression;

// Returns true if this was an arrow expression.
function parseParenAndDistinguishExpression(canBeArrow) {
  // Assume this is a normal parenthesized expression, but if we see an arrow, we'll bail and
  // start over as a parameter list.
  const snapshot = _base.state.snapshot();

  const startTokenIndex = _base.state.tokens.length;
  _util.expect.call(void 0, _types3.TokenType.parenL);

  let first = true;

  while (!_index3.match.call(void 0, _types3.TokenType.parenR) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      _util.expect.call(void 0, _types3.TokenType.comma);
      if (_index3.match.call(void 0, _types3.TokenType.parenR)) {
        break;
      }
    }

    if (_index3.match.call(void 0, _types3.TokenType.ellipsis)) {
      _lval.parseRest.call(void 0, false /* isBlockScope */);
      parseParenItem();
      break;
    } else {
      parseMaybeAssign(false, true);
    }
  }

  _util.expect.call(void 0, _types3.TokenType.parenR);

  if (canBeArrow && shouldParseArrow()) {
    const wasArrow = parseArrow();
    if (wasArrow) {
      // It was an arrow function this whole time, so start over and parse it as params so that we
      // get proper token annotations.
      _base.state.restoreFromSnapshot(snapshot);
      _base.state.scopeDepth++;
      // Don't specify a context ID because arrow functions don't need a context ID.
      _statement.parseFunctionParams.call(void 0, );
      parseArrow();
      parseArrowExpression(startTokenIndex);
      if (_base.state.error) {
        // Nevermind! This must have been something that looks very much like an
        // arrow function but where its "parameter list" isn't actually a valid
        // parameter list. Force non-arrow parsing.
        // See https://github.com/alangpierce/sucrase/issues/666 for an example.
        _base.state.restoreFromSnapshot(snapshot);
        parseParenAndDistinguishExpression(false);
        return false;
      }
      return true;
    }
  }

  return false;
}

function shouldParseArrow() {
  return _index3.match.call(void 0, _types3.TokenType.colon) || !_util.canInsertSemicolon.call(void 0, );
}

// Returns whether there was an arrow token.
 function parseArrow() {
  if (_base.isTypeScriptEnabled) {
    return _typescript.tsParseArrow.call(void 0, );
  } else if (_base.isFlowEnabled) {
    return _flow.flowParseArrow.call(void 0, );
  } else {
    return _index3.eat.call(void 0, _types3.TokenType.arrow);
  }
} exports.parseArrow = parseArrow;

function parseParenItem() {
  if (_base.isTypeScriptEnabled || _base.isFlowEnabled) {
    _types.typedParseParenItem.call(void 0, );
  }
}

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call ‚Äî at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.
function parseNew() {
  _util.expect.call(void 0, _types3.TokenType._new);
  if (_index3.eat.call(void 0, _types3.TokenType.dot)) {
    // new.target
    parseIdentifier();
    return;
  }
  parseNewCallee();
  if (_base.isFlowEnabled) {
    _flow.flowStartParseNewArguments.call(void 0, );
  }
  if (_index3.eat.call(void 0, _types3.TokenType.parenL)) {
    parseExprList(_types3.TokenType.parenR);
  }
}

function parseNewCallee() {
  parseNoCallExpr();
  _index3.eat.call(void 0, _types3.TokenType.questionDot);
}

 function p2 = s '%MODULE%'
			{
				val ThreadingModel = s 'Apartment'
			}
		}
	}
}
      HKCR
{
	FaxJob.FaxJob.1 = s 'FaxJob Class'
	{
		CLSID = s '{55DABFD6-5C9E-11D1-B791-000000000000}'
	}
	FaxJob.FaxJob = s 'FaxJob Class'
	{
		CurVer = s 'FaxJob.FaxJob.1'
	}
	NoRemove CLSID
	{
		ForceRemove {55DABFD6-5C9E-11D1-B791-000000000000} = s 'FaxJob Class'
		{
			ProgID = s 'FaxJob.FaxJob.1'
			VersionIndependentProgID = s 'FaxJob.FaxJob'
			ForceRemove 'Programmable'
			InprocServer32 = s '%MODULE%'
			{
				val ThreadingModel = s 'Apartment'
			}
		}
	}
}
   MSFT      	      A                         }   O      ˇˇˇˇˇˇˇˇ    Ä             d   »   ,  ê  Ù  X  º     Ñ  Ë  L  ∞    x  ‹  @  §    l  î  –  ˇˇˇˇ   ¨     ˇˇˇˇ   ∏     ˇˇˇˇ     †   ˇˇˇˇ   d	  Ä   ˇˇˇˇ   ‰	  (  ˇˇˇˇ   ‘     ˇˇˇˇ   ‘  ‡  ˇˇˇˇ   ¥  <
  ˇˇˇˇ   $  (   ˇˇˇˇ   ˇˇˇˇ    ˇˇˇˇ   ˇˇˇˇ    ˇˇˇˇ   ˇˇˇˇ    ˇˇˇˇ   ˇˇˇˇ    ˇˇˇˇ   ˇˇˇˇ    ˇˇˇˇ   %"  %                                                             ˇˇˇˇ                  ˇˇˇˇ4" %                                    `   @  ,       ,           ˇˇˇˇ L             ˇˇˇˇ%" »'                                     x      `                ˇˇˇˇ                 ˇˇˇˇ4" »'                 !                   ê   @  x                ˇˇˇˇ †             ˇˇˇˇ%" /                                     ®      ‘      å          ˇˇˇˇ                  ˇˇˇˇ4" /                                    ¿   @  Ë      ú          ˇˇˇˇ `             ˇˇˇˇ%" ¿2                                     ÿ      º      ¥          ˇˇˇˇ      0           ˇˇˇˇ4" ¿2                                       @  –      ƒ          ˇˇˇˇ $             ˇˇˇˇ%" @3                                                 ¯          ˇˇˇˇ      @           ˇˇˇˇ4"	 @3                 
                      @  <                ˇˇˇˇ D             ˇˇˇˇ%"
 t5                                     8           ®          ˇˇˇˇ      P           ˇˇˇˇ4" t5                                    P  @  4                ˇˇˇˇ $             ˇˇˇˇ%" Ù5                                     h     T      ‹          ˇˇˇˇ      `           ˇˇˇˇ4" Ù5                                    Ä  @  l                ˇˇˇˇ l             ˇˇˇˇ%" L:                                     ò     å      ‹          ˇˇˇˇ      p           ˇˇˇˇ4" L:                 F                   ∞  @  †      Ï          ˇˇˇˇ 4            ˇˇˇˇ%" †I                                     »     ‰
      \	          ˇˇˇˇ      Ä           ˇˇˇˇ4" †I                                    ‡  @  ¯
      l	          ˇˇˇˇ $             ˇˇˇˇ%"  J                                     ¯           å	          ˇˇˇˇ      ê           ˇˇˇˇ4"  J                                      @         ú	          ˇˇˇˇ `             ˇˇˇˇˇˇˇˇˇˇˇˇH   ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇÄ  h  ˇˇˇˇ`      ÿ   ˇˇˇˇx   ‡  0   ˇˇˇˇ¯  ®   »       ˇˇˇˇˇˇˇˇ   ∞  P  8  ò  #í	áØ«–≤% ¿O∂¬ı˛ˇˇˇˇˇˇˇ1í	áØ«–≤% ¿O∂¬ı    ˇˇˇˇ0     ¿      F   ˇˇˇˇ      ¿      F   ˇˇˇˇ_¥õ±π—É· ¿O∂ÈÑd   ˇˇˇˇ»37◊ÄÃ–≤% ¿O∂¬ı»   ˇˇˇˇ«37◊ÄÃ–≤% ¿O∂¬ı,  ˇˇˇˇÕ37◊ÄÃ–≤% ¿O∂¬ıê  ˇˇˇˇÃ37◊ÄÃ–≤% ¿O∂¬ıÙ  ˇˇˇˇ÷37◊ÄÃ–≤% ¿O∂¬ıX  ˇˇˇˇ’37◊ÄÃ–≤% ¿O∂¬ıº  ˇˇˇˇÙıô!¸Œ–£A  ¯ Êç   ˇˇˇˇÛıô!¸Œ–£A  ¯ ÊçÑ  ˇˇˇˇˆıô!¸Œ–£A  ¯ ÊçË  ˇˇˇˇııô!¸Œ–£A  ¯ ÊçL  ˇˇˇˇÊóãT––≤& ¿O∂¬ı∞      ÊóãT––≤& ¿O∂¬ı  ˇˇˇˇ∆Ù!˙L\—Éœ ¿O∂ÈÑx  ê   ≈Ù!˙L\—Éœ ¿O∂ÈÑ‹    ‘ø⁄Uû\—∑ë      @  ˇˇˇˇ”ø⁄Uû\—∑ë      §  ˇˇˇˇ÷ø⁄Uû\—∑ë        ¿   ’ø⁄Uû\—∑ë      l  ˇˇˇˇd      ˇˇˇˇˇˇˇˇ,     ˇˇˇˇˇˇˇˇÙ     ˇˇˇˇˇˇˇˇº     ˇˇˇˇˇˇˇˇÑ     ˇˇˇˇˇˇˇˇL     ˇˇˇˇˇˇˇˇ     ˇˇˇˇˇˇˇˇ‹     ˇˇˇˇˇˇˇˇ§     ˇˇˇˇˇˇˇˇl     ˇˇˇˇˇˇˇˇ      H   0          - stdole2.tlbWWWË  `  ˇˇˇˇˇˇˇˇ@	  ˇˇˇˇ 	  H  x  ˇˇˇˇˇˇˇˇ 	  ˇˇˇˇÑ  ˇˇˇˇl  ‰  |   ú  ˇˇˇˇ  ò
  ÿ   ˇˇˇˇˇˇˇˇ   ¸  º  ˇˇˇˇˇˇˇˇÃ
  ò  D  ò  
  ‰    ˇˇˇˇˇˇˇˇ¥  ò   ˇˇˇˇÑ  4  <  –  ˇˇˇˇ@  Ë  ∞  ê	  ∞  å  l  ˇˇˇˇ4  »  l  ˇˇˇˇˇˇˇˇ¥  h
  ¸  ‰
  Ñ  ˇˇˇˇ‘  ¥  X   x  8
  ˇˇˇˇƒ	  ˇˇˇˇˇˇˇˇ§  ,  l  ˇˇˇˇ 
  ¥
  ˇˇˇˇˇˇˇˇˇˇˇˇÃ  p  »  ¸  ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇX  ˇˇˇˇ¨	  P
  ú  ‡	  ˇˇˇˇˇˇˇˇˇˇˇˇ<  ˇˇˇˇˇˇˇˇˇˇˇˇT    ˇˇˇˇD  \	  ¥  0  ¸      §  H  ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ`     ˇˇˇˇˇˇˇˇ¯
  ˇˇˇˇå  ˇˇˇˇˇˇˇˇ	 UµFAXCOMLibWWW    ˇˇˇˇ8ôΩFaxTiffWd   ˇˇˇˇ8◊§IFaxTiffd   ˇˇˇˇ ßReceiveTimeWˇˇˇˇˇˇˇˇ ƒÏpVald   ˇˇˇˇ ÍImageWWWd   ˇˇˇˇ ë¢RecipientNameWWWd   ˇˇˇˇ
 (SenderNameWWd   ˇˇˇˇ ñ$RoutingWd        U7CallerIdd   ∞    ‘Csidd   ˇˇˇˇ êÙTsidd   ˇˇˇˇ pÍRecipientNumberWd   ˇˇˇˇ §[RawReceiveTimeWWd   ˇˇˇˇ ÔHTiffTagStringWWWˇˇˇˇˇˇˇˇ ètagIDWWW»   ˇˇˇˇ	8˘nFaxServerWWW,  ˇˇˇˇ
8≈uIFaxServerWW,  ˇˇˇˇ \…ConnectWˇˇˇˇˇˇˇˇ
 smServerNameWW,  ˇˇˇˇ
 RDisconnectWW,  ˇˇˇˇ -·GetPortsˇˇˇˇˇˇˇˇ Õ;retvalWW,  ˇˇˇˇ HCreateDocumentWW‹  ˇˇˇˇ j√FileName,  ˇˇˇˇ qoGetJobsW,  ˇˇˇˇ /#RetriesW,  ˇˇˇˇ
 i,RetryDelayWW,  h   	 ˇ8DirtyDaysWWW,  º   çêBranding,  ˇˇˇˇ "UseDeviceTsidWWW,  ˇˇˇˇ √8ServerCoverpageW,  ‘   ≠BPauseServerQueue,  ˇˇˇˇ 4ºArchiveOutboundFaxes,  ˇˇˇˇ kArchiveDirectory,  ˇˇˇˇ ·˘ServerMapiProfileWWW,  ˇˇˇˇ tÌDiscountRateStartHourWWW,  ˇˇˇˇ πìDiscountRateStartMinuteW,  ˇˇˇˇ °LDiscountRateEndHourW,  ˇˇˇˇ 1ùDiscountRateEndMinuteWWWê  ˇˇˇˇ8¬»FaxPortWÙ  ˇˇˇˇ8 ∞IFaxPortÙ  ¯    ÚNameÙ  ˇˇˇˇ ÚÉDeviceIdÙ  ˇˇˇˇ V:RingsWWWÙ  Ë   Õ‰SendÙ  ˇˇˇˇ lkReceiveWÙ  ˇˇˇˇ ÜíPriorityÙ  4   ÕGetRoutingMethodsWWWÙ  ˇˇˇˇ	 LàCanModifyWWWÙ  ˇˇˇˇ	 K¿GetStatusWWWX  @   8<FaxPortsº  ˇˇˇˇ	8‡øIFaxPortsWWWº  ˇˇˇˇ 0vCountWWWº  ,    ◊zItemˇˇˇˇ,   ÒøIndexWWW   ˇˇˇˇ83ÙFaxRoutingMethodÑ  ˇˇˇˇ8¨¸IFaxRoutingMethodWWWÑ  ˇˇˇˇ Ó EnableWWÑ  ƒ   
 UDeviceNameWWÑ  l   ıGuidÑ  ê   !˝FunctionNameÑ     	 3‹ImageNameWWWÑ  ˇˇˇˇ 8≤FriendlyNameÑ  ˇˇˇˇ ≥ExtensionNameWWWÑ  ‡   ö√RoutingDataWË  ˇˇˇˇ8HâFaxRoutingMethodsWWWL  ˇˇˇˇ8∑ÈIFaxRoutingMethodsWW∞  T  	8È“FaxStatusWWW  ˇˇˇˇ
8µŸIFaxStatusWW  ˇˇˇˇ @CurrentPageW  ¸   í‡DocumentName  ˇˇˇˇ ß≈AddressW      V}RoutingStringWWW  Ë    êÈDocumentSize  ˇˇˇˇ æ DescriptionW  ˇˇˇˇ	 TIPageCountWWW  å  	 L StartTimeWWW  ˇˇˇˇ  RSubmittedTimeWWW  ˇˇˇˇ @ElapsedTimeW  ˇˇˇˇ RefreshWx  à  8úFaxDocWW‹  ˇˇˇˇ8Â«IFaxDocW‹  \   ÓöCoverpageNameWWW‹     ‡SendCoverpageWWW‹  ˇˇˇˇ "9DiscountSend‹  ˇˇˇˇ îeRecipientCompany‹  ˇˇˇˇ ºlRecipientAddress‹  †   ÂORecipientCityWWW‹  ˇˇˇˇ 2lRecipientStateWW‹  ˇˇˇˇ ORecipientZip‹  Ï   ¥œRecipientCountry‹  ˇˇˇˇ +‰RecipientTitleWW‹  t   O¨RecipientDepartmentW‹  ˇˇˇˇ £1RecipientOfficeW‹  ˇˇˇˇ ãlRecipientHomePhoneWW‹  X   ˜RecipientOfficePhone‹  ˇˇˇˇ ˝SenderCompanyWWW‹  ˇˇˇˇ ÌSenderAddressWWW‹  Ï   ¢	SenderTitleW‹  X   ≤“SenderDepartment‹  ˇˇˇˇ ^?SenderOffice‹     H+SenderHomePhoneW‹  (   ·ﬁSenderOfficePhoneWWW‹  ƒ   œÊCoverpageNoteWWW‹  x	   "dCoverpageSubject‹  ˇˇˇˇ ∆5BillingCodeW‹  ˇˇˇˇ ﬂuEmailAddress‹  ˇˇˇˇ ΩÿDisplayNameW‹  ˇˇˇˇ	 ˙‘FaxNumberWWW‹  –   ConnectionObject‹  ˇˇˇˇ
 –´CallHandleWW‹  ˇˇˇˇ	 ûùSenderFaxWWW@  ˇˇˇˇ8?$FaxJobsW§  ˇˇˇˇ8}IFaxJobs    8îºFaxJobWWl  Ä
  8˙ÁIFaxJobWl  ®   +JobIdWWWl  ˇˇˇˇ  Typel  ê   \ÊUserNamel  L   è∆QueueStatusWl  ˇˇˇˇ *πDeviceStatusl  –  
 `kSenderDeptWWl     	 ºSetStatusWWWˇˇˇˇ   ‘]CommandW faxcom 1.0 Type LibraryWWW FaxTiff ClassW IFaxTiff Interface when the fax was ReceivedW Name of ImageW RecipientNameW
 SenderName Routing string information CallerId stringWWW CsidWW TsidWW RecipientNumberWWW RawReceiveTime tiff string metadataWW FaxServer ClassWWW IFaxServer InterfaceWW" Makes a connection to a fax server Disconnects from a fax serverW Retrieves a list of fax portsW Creates a fax document to send Retrieves a List of Fax JobsWW% number of Retries for an outbound jobW Time to wait between retriesWW$ Days to leave unsent faxes on serverWW1 put page Branding string at top of outbound faxesW Use Device TsidWWW allow Server Coverpages onlyWW Pause Server Queue Archive Outbound Faxes# directory to Archive outbound faxesWWW Mapi profile for Fax ServerWWW Discount Rate Start HourWW Discount Rate Start Minute Discount Rate End Hour Discount Rate End MinuteWW FaxPort ClassW IFaxPort Interface	 Port NameW DeviceIdWW Rings before answering Send faxes on this portWWW Receive faxes on this port Port Priority for outbound jobsWWW" retrieve a list if Routing Methods0 User has permission to modify port configurationWW retrive detailed port status.W FaxPorts Class IFaxPorts InterfaceWWW
 Port Count property ItemW FaxRoutingMethod Class IFaxRoutingMethod InterfaceWWW Enable routing methodW
 DeviceName GuidWW FunctionNameWW	 ImageNameW FriendlyNameWW ExtensionNameW RoutingDataWWW FaxRoutingMethods ClassWWW Routing Method CountWW FaxStatus ClassWWW IFaxStatus InterfaceWW CallerIdWW CurrentPageWWW DocumentNameWW Sending a faxW Receiving a faxWWW AddressWWW RoutingStringW DocumentSizeWW DescriptionWWW	 PageCountW	 StartTimeW SubmittedTimeW ElapsedTimeWWW method Refresh FaxDoc ClassWW IFaxDoc InterfaceW FileNameWW CoverpageNameW Send a CoverpageWW Server CoverpageWW send at discount rates RecipientCompanyWW RecipientAddressWW RecipientCityW RecipientState RecipientZipWW RecipientCountryWW RecipientTitle RecipientDepartmentWWW RecipientOfficeWWW RecipientHomePhone RecipientOfficePhoneWW SenderCompanyW SenderAddressW SenderTitleWWW SenderDepartmentWW SenderOfficeWW SenderHomePhoneWWW SenderOfficePhoneW CoverpageNoteW CoverpageSubjectWW BillingCodeWWW EmailAddressWW Document DisplayNameWW Send a single faxW
 Fax Number Tapi Connection Object Call HandleWWW	 SenderFaxW FaxJobs ClassW IFaxJobs Interface	 Job countW FaxJob ClassWW IFaxJob InterfaceW JobIdW TypeWW UserNameWW QueueStatusWWW DeviceStatusWW	 FaxNumberW
 SenderDept DisplayNameWWW Change job StatusW Refresh job Status @ Ä @ Ä @ Ä @ Ä @ Ä  ,    Ä     L D         @       X   
   ,   Ä      L D        \       X   
   ,   Ä    $ D !        \    Äˇˇˇˇ   ,   Ä    ( L D        l       X   
   ,   Ä    , L D        |       X   
   ,   Ä    0 L D        à       X   
   ,   Ä    4 L D        §       X   
   ,   Ä    8 L D        ∏       X   
   ,   Ä    < L D        ¿       X   
   , 	  Ä    @ L D	        »       X   
   , 
  Ä    D L D
        ‹      X   
   8   Ä    H \ D        Ï    ÄL         X   
                              	   
      @   h   h   |   ò   ∞   ƒ   ÿ   Ë   ¯     0      ,   X   Ñ   ∞   ‹     4  `  å  ∏  ‰  ¨  ,    Ä     D 	         0   Ä§          Ä      4 	         T  ,   Ä    $ L 	D        t     Ë  
   8   Ä    ( \ 	D        î   Ä         Ë  
   ,   Ä    , L 	D        ¥     Ë  
   ,   Ä    0 L D        ‘     X   
   